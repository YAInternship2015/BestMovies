Задание 1.
Написать приложение, в котором будет один экран с таблицей (UITableViewController). В таблице каждая ячейка (UITableViewCell) должна содержать следующую информацию: картинка (UIImageView) и справа от нее текст (UILabel). В таблице должно быть 10 ячеек высотой 80 пикселей. В качестве картинки показать любую картинку добавленную в проект и в качестве текста показать любой текст, но они должны быть разными для каждой ячейки. Экран должен быть создан в Storyboard с использованием Autolayout.

Задание 2.
К выполненному заданию 1 необходимо добавить следующий функционал:
Смена вида представления данных - добавить возможность переключения между UITableView и UICollectionView. В UICollectionViewCell необходимо отображать только картинку в весь размер ячейки, что-то вроде этого http://www.appcoda.com/wp-content/uploads/2013/01/RecipePhoto-App-First-Version.jpg
Хранить данные моделей в plist-файле
Добавить возможность добавлять новые элементы - пользователь может ввести текст для новой модели, этот текст не может быть короче трех символов. Картинку пока не выбыраем. Модель сохраняется в plist. После сохранения модели она должна добавиться в plist и отобразиться в таблице и collection view. 

Раскрою Вам некоторые детали реализации:
Отображение данных в UICollectionView. Вам необходимо создать новый вью контроллер, который бы умел отображать те же самые данные, что и табличный, в UICollectionView. У него будет абсолютно тот же датасорс, что и у табличного контроллера (удобно, не так ли?). Нужно будет реализовать ячейку (наследника UICollectionViewCell) и научить ее заполняться моделью. Не забывайте использовать Autolayout. 
По поводу переключения режимов UITableView/UICollectionView. Сама кнопка переключения должна находиться в UINavigationBar в левом углу (как кнопка Logout здесь http://i.stack.imgur.com/FWDcH.png). Для того, чтобы у Вас появился UINavigationBar, необходимо показывать Ваш вью контроллер внутри UINavigationController. По архитектуре - у Вас будет один так называемый ContainerViewController, который в себе будет показывать либо табличный, либо collectionview контроллеры. Называется это Nested View Controllers. У Apple есть гайд https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/CreatingCustomContainerViewControllers/CreatingCustomContainerViewControllers.html, также в гугле по запросу “ios nested view controllers” куча топиков и туториалов. Этот ContainerViewController будет хранить в себе в свойствах два вью контроллера и по нажатию кнопки смены режимов Вы будете менять в отображаемый вью контроллер. Можете менять анимировано, можете без анимации.
Хранение данный в plist - пока реализуем такое решение, в будущем возможно переедем на Core Data. Вам необходимо создать новый файл *.plist, затащить его в проект. Далее в Xcode с помощью редактора в этом plist необходимо создать структуру, повторяющую Вашу модель. Вот пример https://www.dropbox.com/s/yd2s55498xhllse/Screenshot%202015-08-17%2016.45.10.png?dl=0 . Только у Вас будет имя картинки и текст. И Ваш датасорс должен научиться создавать модели из это plist. Как это сделать отлично подскажет гугл по запросу “ios load data from plist”. Что примечательно, если Вы правильно выполнили первое задание, то это изменение коснется исключительно логики датасорса. Нужно будет переписать ту чаcть, которая заполняет внутренний массив, чтобы он заполнялся контентом файла.
Добавление нового элемента - для этого Вам необходимо будет добавить еще один экран, где пользователь будет вводить данные для новой модели. Для перехода на этот экран в UINavigationBar (где слева уже будет кнопка смены режимов представления) справа необходимо добавить кнопку “+”. На самом экране должен быть пока только один UITextField для ввода текста Вашей модели. Картинкой возможно займемся в следующих заданиях. Также на этом экране должна быть кнопка Save, она либо лежит на View где-то ниже поля ввода, либо справа в UINavigationBar. 
Валидация введенной строки: по нажатию на Save вью контроллер должен передать введенную пользователем строку объекту-“валидатору”. Этот валидатор - это объект, у которого есть всего один метод, вроде - (BOOL)isValidModelTitle:(NSString *)title error:(NSError **)error, который в себе уже будет проверять строку на длину. Две звездочки у NSerror не спроста, это для того, чтобы метод принял пустой объект NSError и заполнил его внутри себя, если строка невалидна. Почитать о том, как это сделать, можно здесь http://nshipster.com/nserror/ в разделе Producing (вообще весь пост прочитайте). После валидации если объект невалиден, то вью контроллер должен отобразить в интерфейсе ошибку (как это сделать смотри в том же посте). Если текст валиден, то необходимо создать модель с данной строкой.
Создание модели. Как Вы уже могли догадаться, создание новых моделей - это работа не для вью контроллера. Этим должен заниматься класс-”фабрика”. За громким названием кроется простой класс с одним методом “создай мне объект с текстом таким-то”. Внутри этого метода создается новая пустая модель и затем она заполняется строкой. Зачастую методы фабрик статичны, поэтому метод будет со знаком “+”. Всё
Сохранения модели в plist. Это опять же работа не для вью контроллера. После создания новой модели в фабрике у вью контроллера есть новая модель. Он ее должен отдать тому, кто знает, где храняться остальные модели. Это Ваш датасорс. Хотя логичнее было бы это делать в каком-нибудь DataManager’е, но мы сделаем в датасорсе. То есть у датасорса появится новый метод вроде saveModel:, который будет добавлять новую запись в plist. Этот метод будет создавать NSDictionary из Вашей модели с такими же ключами, какие в этом plist уже есть (Вы ведь уже создавали plist с полями для Ваших моделей). И затем этот NSDictionary надо сохранить в plist. Как это сделать знает гугл, “ios write nsdictionary to plist”. Вдруг не найдете - вот http://stackoverflow.com/questions/6311037/save-nsdictionary-to-plist. Также можете сделать автоматический переход на предыдущий экран.
Отображение новой модели в таблице/collection view. После создания и сохранения новой модели в plist, она должна отобразиться внутри таблицы и collection view. Это делается в два этапа:
новая модель должна появиться во внутреннем массиве датасорса. Так как мы не знаем, сколько всего экземпляров датасорса существует в приложении, нам тяжело их всех оповестить о том, что нужно пересчитать свой внутренний массив из файла. Для таких случаев существует NSNotificationCenter. Датасорс, который добавляет новую модель, “постит” в NSNotificationCenter новый нотификейшн с именем, которое вы придумаете, вроде “DataFileContentDidChange”, и его получат все те, кто подписался в NSNotificationCenter на него. Пример такого взаимодействия немного показан здесь http://stackoverflow.com/questions/2191594/send-and-receive-messages-through-nsnotificationcenter-in-objective-c. Вообще про NSNotificationCenter написано в эппловой документации да и в гугле полно информации тоже. Ваш датасорс в своем init должен подписываться на такой нотификейшн и в своем dealloc отписываться от него. При получении нотификейшна датасорс должен заново заполнить свой внутренний массив из файла
необходимо оповестить вью контроллеры таблицы и collection view о том, что данные в их датасорсах изменились и нужно перезагрузить таблицу/collection view. Здесь можно воспользоваться делегированием, так как у нас на один датасорс приходится один так сказать “потребитель” данных. То есть при создании датасорса вью контроллер передает себя как параметр в кастомный инит датасорса (вроде initWithDelegate:), затем датасорс хранит значение этого параметра в себе и сообщает этому объекту, что данные внутри него изменились. Датасорс должен в своем *.h файле объявить протокол вроде ModelsDataSourceDelegate, в котором будет один метод, вроде dataWasChanged. Вью контроллер должен реализовать такой протокол, чтобы датасорс затем вызвал этот метод у своего делегата. Вью контроллер в этом методе должен перезагрузить таблицу/collection view. Пример реализации паттерга “делегат” есть тут http://code.tutsplus.com/articles/design-patterns-delegation--cms-23901б, и, как обычно, в гугле есть куча материала.